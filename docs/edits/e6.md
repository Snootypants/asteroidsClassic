Run 1

Summary

Defined startNewStage before it is captured in updateAsteroidCounts, preventing the ReferenceError that stopped rendering and produced the black screen. 

Renamed the HUD component file to Hud.jsx so the case-sensitive import resolves correctly during builds. 

Adjusted the bullet limit test to click the start button by its accessible name, avoiding ambiguous matches

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/App.test.jsx b/src/App.test.jsx
index e3952855578eb4251554f9c6cdd23cc0786cc5f5..baa03d6a84206742a6dd2525ad3b4db3c07d39f9 100644
--- a/src/App.test.jsx
+++ b/src/App.test.jsx
@@ -1,32 +1,32 @@
 import { render, fireEvent, screen, act } from '@testing-library/react';
 import { describe, it, expect, vi } from 'vitest';
 import App from './App.jsx';
 import { BULLET_FIRE_RATE, MAX_BULLETS } from './utils/constants.js';
 
 describe('bullet firing limits', () => {
   it('caps bullets at MAX_BULLETS when holding fire', () => {
     vi.useFakeTimers();
     vi.setSystemTime(0);
 
     render(<App />);
 
     // Click StartOverlay "Waves" button to start
-    const wavesButton = screen.getByText(/waves/i);
+    const wavesButton = screen.getByRole('button', { name: /^Waves\b/i });
     fireEvent.click(wavesButton);
 
     // Hold Space to fire
     fireEvent.keyDown(window, { code: 'Space' });
 
     for (let i = 0; i < MAX_BULLETS + 2; i++) {
       act(() => {
         vi.advanceTimersByTime(BULLET_FIRE_RATE);
       });
     }
 
     const count = Number(screen.getByTestId('bullet-count').textContent);
     expect(count).toBe(MAX_BULLETS);
 
     fireEvent.keyUp(window, { code: 'Space' });
     vi.useRealTimers();
   });
 });
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/hooks/useGameWorld.js b/src/hooks/useGameWorld.js
index f7a5be805fc817d2b7f5048fea01ef725aa0fa4f..a705ab9cdf9b736cc6afb2b4934d7a03d527a266 100644
--- a/src/hooks/useGameWorld.js
+++ b/src/hooks/useGameWorld.js
@@ -61,108 +61,108 @@ export function useGameWorld({
   const xpNeededForNextLevel = useCallback((level) => Math.round(XP_LEVEL_BASE * Math.pow(XP_LEVEL_GROWTH, Math.max(0, level - 1))), []);
 
   const triggerLevelUp = useCallback((newLevel) => {
     levelRef.current = newLevel;
     setUiState(prev => ({ ...prev, level: newLevel }));
   }, [setUiState]);
 
   const addXp = useCallback((amount) => {
     xpRef.current += amount;
 
     // Check for level up
     const currentLevel = levelRef.current;
     const requiredXp = xpNeededForNextLevel(currentLevel);
 
     if (xpRef.current >= requiredXp) {
       const newLevel = currentLevel + 1;
       // Remove used XP for next level calculation
       xpRef.current -= requiredXp;
       triggerLevelUp(newLevel);
     }
 
     // Update UI
     setUiState(prev => ({ ...prev, xp: xpRef.current }));
   }, [xpNeededForNextLevel, triggerLevelUp, setUiState]);
 
+  const startNewStage = useCallback((stageNumber, asteroidCount) => {
+    stageRef.current = stageNumber;
+    baseAsteroidCountRef.current = asteroidCount;
+    stageClearedRef.current = false;
+
+    // Clear bullets
+    bulletsRef.current = [];
+    setBulletCount(0);
+
+    // Reset and re-center ship with zero velocity
+    const ship = shipRef.current;
+    if (ship) {
+      ship.x = WORLD_WIDTH / 2;
+      ship.y = WORLD_HEIGHT / 2;
+      ship.vx = 0;
+      ship.vy = 0;
+    }
+
+    // Initialize new asteroids for the stage
+    initializeAsteroids(asteroidCount);
+
+    // Regenerate starfield for variety
+    generateStarfield();
+
+    // Update UI stage indicator
+    setUiState(prev => ({ ...prev, stage: stageNumber }));
+  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
+
   const updateAsteroidCounts = useCallback(() => {
     const counts = { large: 0, medium: 0, small: 0 };
 
     asteroidsRef.current.forEach(asteroid => {
       if (asteroid.size === ASTEROID_SIZE_LARGE) counts.large++;
       else if (asteroid.size === ASTEROID_SIZE_MEDIUM) counts.medium++;
       else if (asteroid.size === ASTEROID_SIZE_SMALL) counts.small++;
     });
 
     asteroidCountsRef.current = counts;
 
     // Check if stage is cleared (no asteroids left)
     const totalAsteroids = counts.large + counts.medium + counts.small;
     if (totalAsteroids === 0 && !stageClearedRef.current) {
       stageClearedRef.current = true;
       // Trigger stage clear effect
       stageClearEffectRef.current.trigger();
 
       // After a delay, start hyperspace jump to next stage
       setTimeout(() => {
         if (shipRef.current && hyperSpaceJumpEffectRef.current) {
           hyperSpaceJumpEffectRef.current.trigger(
             shipRef.current.angle,
             stageRef.current,
             baseAsteroidCountRef.current + Math.floor(stageRef.current * 0.5),
             (stageNumber, asteroidCount) => {
               setTimeout(() => startNewStage(stageNumber, asteroidCount), 100);
             }
           );
           hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
         }
       }, 2000);
     }
   }, [shipRef, stageClearEffectRef, hyperSpaceJumpEffectRef, starsRef, startNewStage]);
 
-  const startNewStage = useCallback((stageNumber, asteroidCount) => {
-    stageRef.current = stageNumber;
-    baseAsteroidCountRef.current = asteroidCount;
-    stageClearedRef.current = false;
-
-    // Clear bullets
-    bulletsRef.current = [];
-    setBulletCount(0);
-
-    // Reset and re-center ship with zero velocity
-    const ship = shipRef.current;
-    if (ship) {
-      ship.x = WORLD_WIDTH / 2;
-      ship.y = WORLD_HEIGHT / 2;
-      ship.vx = 0;
-      ship.vy = 0;
-    }
-
-    // Initialize new asteroids for the stage
-    initializeAsteroids(asteroidCount);
-
-    // Regenerate starfield for variety
-    generateStarfield();
-
-    // Update UI stage indicator
-    setUiState(prev => ({ ...prev, stage: stageNumber }));
-  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
-
   return {
     // refs
     starsRef,
     asteroidsRef,
     asteroidCountsRef,
     xpRef,
     levelRef,
     stageRef,
     baseAsteroidCountRef,
     stageClearedRef,
     // functions
     generateStarfield,
     initializeAsteroids,
     xpNeededForNextLevel,
     triggerLevelUp,
     addXp,
     updateAsteroidCounts,
     startNewStage,
   };
 }
 
EOF
)

-----
Run 2:

Summary

Renamed the HUD component file to Hud.jsx so the app can resolve the import on case-sensitive systems, restoring the UI instead of a blank screen.

Reordered the stage transition hooks so startNewStage is defined before it is referenced, ensuring asteroid clearing triggers the hyperspace animation and next stage setup without runtime errors.

Updated the bullet-cap test to locate the Waves start button by role, matching the overlay markup and keeping the regression test reliable

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/App.test.jsx b/src/App.test.jsx
index e3952855578eb4251554f9c6cdd23cc0786cc5f5..2f592fc5ae8c4d539764db3296d6297a87ab9e14 100644
--- a/src/App.test.jsx
+++ b/src/App.test.jsx
@@ -1,32 +1,32 @@
 import { render, fireEvent, screen, act } from '@testing-library/react';
 import { describe, it, expect, vi } from 'vitest';
 import App from './App.jsx';
 import { BULLET_FIRE_RATE, MAX_BULLETS } from './utils/constants.js';
 
 describe('bullet firing limits', () => {
   it('caps bullets at MAX_BULLETS when holding fire', () => {
     vi.useFakeTimers();
     vi.setSystemTime(0);
 
     render(<App />);
 
     // Click StartOverlay "Waves" button to start
-    const wavesButton = screen.getByText(/waves/i);
+    const wavesButton = screen.getByRole('button', { name: /waves/i });
     fireEvent.click(wavesButton);
 
     // Hold Space to fire
     fireEvent.keyDown(window, { code: 'Space' });
 
     for (let i = 0; i < MAX_BULLETS + 2; i++) {
       act(() => {
         vi.advanceTimersByTime(BULLET_FIRE_RATE);
       });
     }
 
     const count = Number(screen.getByTestId('bullet-count').textContent);
     expect(count).toBe(MAX_BULLETS);
 
     fireEvent.keyUp(window, { code: 'Space' });
     vi.useRealTimers();
   });
 });
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/hooks/useGameWorld.js b/src/hooks/useGameWorld.js
index f7a5be805fc817d2b7f5048fea01ef725aa0fa4f..a705ab9cdf9b736cc6afb2b4934d7a03d527a266 100644
--- a/src/hooks/useGameWorld.js
+++ b/src/hooks/useGameWorld.js
@@ -61,108 +61,108 @@ export function useGameWorld({
   const xpNeededForNextLevel = useCallback((level) => Math.round(XP_LEVEL_BASE * Math.pow(XP_LEVEL_GROWTH, Math.max(0, level - 1))), []);
 
   const triggerLevelUp = useCallback((newLevel) => {
     levelRef.current = newLevel;
     setUiState(prev => ({ ...prev, level: newLevel }));
   }, [setUiState]);
 
   const addXp = useCallback((amount) => {
     xpRef.current += amount;
 
     // Check for level up
     const currentLevel = levelRef.current;
     const requiredXp = xpNeededForNextLevel(currentLevel);
 
     if (xpRef.current >= requiredXp) {
       const newLevel = currentLevel + 1;
       // Remove used XP for next level calculation
       xpRef.current -= requiredXp;
       triggerLevelUp(newLevel);
     }
 
     // Update UI
     setUiState(prev => ({ ...prev, xp: xpRef.current }));
   }, [xpNeededForNextLevel, triggerLevelUp, setUiState]);
 
+  const startNewStage = useCallback((stageNumber, asteroidCount) => {
+    stageRef.current = stageNumber;
+    baseAsteroidCountRef.current = asteroidCount;
+    stageClearedRef.current = false;
+
+    // Clear bullets
+    bulletsRef.current = [];
+    setBulletCount(0);
+
+    // Reset and re-center ship with zero velocity
+    const ship = shipRef.current;
+    if (ship) {
+      ship.x = WORLD_WIDTH / 2;
+      ship.y = WORLD_HEIGHT / 2;
+      ship.vx = 0;
+      ship.vy = 0;
+    }
+
+    // Initialize new asteroids for the stage
+    initializeAsteroids(asteroidCount);
+
+    // Regenerate starfield for variety
+    generateStarfield();
+
+    // Update UI stage indicator
+    setUiState(prev => ({ ...prev, stage: stageNumber }));
+  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
+
   const updateAsteroidCounts = useCallback(() => {
     const counts = { large: 0, medium: 0, small: 0 };
 
     asteroidsRef.current.forEach(asteroid => {
       if (asteroid.size === ASTEROID_SIZE_LARGE) counts.large++;
       else if (asteroid.size === ASTEROID_SIZE_MEDIUM) counts.medium++;
       else if (asteroid.size === ASTEROID_SIZE_SMALL) counts.small++;
     });
 
     asteroidCountsRef.current = counts;
 
     // Check if stage is cleared (no asteroids left)
     const totalAsteroids = counts.large + counts.medium + counts.small;
     if (totalAsteroids === 0 && !stageClearedRef.current) {
       stageClearedRef.current = true;
       // Trigger stage clear effect
       stageClearEffectRef.current.trigger();
 
       // After a delay, start hyperspace jump to next stage
       setTimeout(() => {
         if (shipRef.current && hyperSpaceJumpEffectRef.current) {
           hyperSpaceJumpEffectRef.current.trigger(
             shipRef.current.angle,
             stageRef.current,
             baseAsteroidCountRef.current + Math.floor(stageRef.current * 0.5),
             (stageNumber, asteroidCount) => {
               setTimeout(() => startNewStage(stageNumber, asteroidCount), 100);
             }
           );
           hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
         }
       }, 2000);
     }
   }, [shipRef, stageClearEffectRef, hyperSpaceJumpEffectRef, starsRef, startNewStage]);
 
-  const startNewStage = useCallback((stageNumber, asteroidCount) => {
-    stageRef.current = stageNumber;
-    baseAsteroidCountRef.current = asteroidCount;
-    stageClearedRef.current = false;
-
-    // Clear bullets
-    bulletsRef.current = [];
-    setBulletCount(0);
-
-    // Reset and re-center ship with zero velocity
-    const ship = shipRef.current;
-    if (ship) {
-      ship.x = WORLD_WIDTH / 2;
-      ship.y = WORLD_HEIGHT / 2;
-      ship.vx = 0;
-      ship.vy = 0;
-    }
-
-    // Initialize new asteroids for the stage
-    initializeAsteroids(asteroidCount);
-
-    // Regenerate starfield for variety
-    generateStarfield();
-
-    // Update UI stage indicator
-    setUiState(prev => ({ ...prev, stage: stageNumber }));
-  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
-
   return {
     // refs
     starsRef,
     asteroidsRef,
     asteroidCountsRef,
     xpRef,
     levelRef,
     stageRef,
     baseAsteroidCountRef,
     stageClearedRef,
     // functions
     generateStarfield,
     initializeAsteroids,
     xpNeededForNextLevel,
     triggerLevelUp,
     addXp,
     updateAsteroidCounts,
     startNewStage,
   };
 }
 
EOF
)

----
Run 3:

Summary

Renamed the HUD component to Hud.jsx so the App import resolves on case-sensitive systems, allowing the HUD to render instead of failing with a blank screen. 

Reordered the stage transition helpers so startNewStage is defined before being used in updateAsteroidCounts, removing the initialization ReferenceError that stopped the game loop. 

Updated the bullet limit test to click the Waves button via its accessible name, avoiding ambiguous text matches. 



 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/App.test.jsx b/src/App.test.jsx
index e3952855578eb4251554f9c6cdd23cc0786cc5f5..92ae63fbf5197732fa96f26e19055653b9ef4f40 100644
--- a/src/App.test.jsx
+++ b/src/App.test.jsx
@@ -1,32 +1,32 @@
 import { render, fireEvent, screen, act } from '@testing-library/react';
 import { describe, it, expect, vi } from 'vitest';
 import App from './App.jsx';
 import { BULLET_FIRE_RATE, MAX_BULLETS } from './utils/constants.js';
 
 describe('bullet firing limits', () => {
   it('caps bullets at MAX_BULLETS when holding fire', () => {
     vi.useFakeTimers();
     vi.setSystemTime(0);
 
     render(<App />);
 
     // Click StartOverlay "Waves" button to start
-    const wavesButton = screen.getByText(/waves/i);
+    const wavesButton = screen.getByRole('button', { name: /^waves/i });
     fireEvent.click(wavesButton);
 
     // Hold Space to fire
     fireEvent.keyDown(window, { code: 'Space' });
 
     for (let i = 0; i < MAX_BULLETS + 2; i++) {
       act(() => {
         vi.advanceTimersByTime(BULLET_FIRE_RATE);
       });
     }
 
     const count = Number(screen.getByTestId('bullet-count').textContent);
     expect(count).toBe(MAX_BULLETS);
 
     fireEvent.keyUp(window, { code: 'Space' });
     vi.useRealTimers();
   });
 });
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/hooks/useGameWorld.js b/src/hooks/useGameWorld.js
index f7a5be805fc817d2b7f5048fea01ef725aa0fa4f..a705ab9cdf9b736cc6afb2b4934d7a03d527a266 100644
--- a/src/hooks/useGameWorld.js
+++ b/src/hooks/useGameWorld.js
@@ -61,108 +61,108 @@ export function useGameWorld({
   const xpNeededForNextLevel = useCallback((level) => Math.round(XP_LEVEL_BASE * Math.pow(XP_LEVEL_GROWTH, Math.max(0, level - 1))), []);
 
   const triggerLevelUp = useCallback((newLevel) => {
     levelRef.current = newLevel;
     setUiState(prev => ({ ...prev, level: newLevel }));
   }, [setUiState]);
 
   const addXp = useCallback((amount) => {
     xpRef.current += amount;
 
     // Check for level up
     const currentLevel = levelRef.current;
     const requiredXp = xpNeededForNextLevel(currentLevel);
 
     if (xpRef.current >= requiredXp) {
       const newLevel = currentLevel + 1;
       // Remove used XP for next level calculation
       xpRef.current -= requiredXp;
       triggerLevelUp(newLevel);
     }
 
     // Update UI
     setUiState(prev => ({ ...prev, xp: xpRef.current }));
   }, [xpNeededForNextLevel, triggerLevelUp, setUiState]);
 
+  const startNewStage = useCallback((stageNumber, asteroidCount) => {
+    stageRef.current = stageNumber;
+    baseAsteroidCountRef.current = asteroidCount;
+    stageClearedRef.current = false;
+
+    // Clear bullets
+    bulletsRef.current = [];
+    setBulletCount(0);
+
+    // Reset and re-center ship with zero velocity
+    const ship = shipRef.current;
+    if (ship) {
+      ship.x = WORLD_WIDTH / 2;
+      ship.y = WORLD_HEIGHT / 2;
+      ship.vx = 0;
+      ship.vy = 0;
+    }
+
+    // Initialize new asteroids for the stage
+    initializeAsteroids(asteroidCount);
+
+    // Regenerate starfield for variety
+    generateStarfield();
+
+    // Update UI stage indicator
+    setUiState(prev => ({ ...prev, stage: stageNumber }));
+  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
+
   const updateAsteroidCounts = useCallback(() => {
     const counts = { large: 0, medium: 0, small: 0 };
 
     asteroidsRef.current.forEach(asteroid => {
       if (asteroid.size === ASTEROID_SIZE_LARGE) counts.large++;
       else if (asteroid.size === ASTEROID_SIZE_MEDIUM) counts.medium++;
       else if (asteroid.size === ASTEROID_SIZE_SMALL) counts.small++;
     });
 
     asteroidCountsRef.current = counts;
 
     // Check if stage is cleared (no asteroids left)
     const totalAsteroids = counts.large + counts.medium + counts.small;
     if (totalAsteroids === 0 && !stageClearedRef.current) {
       stageClearedRef.current = true;
       // Trigger stage clear effect
       stageClearEffectRef.current.trigger();
 
       // After a delay, start hyperspace jump to next stage
       setTimeout(() => {
         if (shipRef.current && hyperSpaceJumpEffectRef.current) {
           hyperSpaceJumpEffectRef.current.trigger(
             shipRef.current.angle,
             stageRef.current,
             baseAsteroidCountRef.current + Math.floor(stageRef.current * 0.5),
             (stageNumber, asteroidCount) => {
               setTimeout(() => startNewStage(stageNumber, asteroidCount), 100);
             }
           );
           hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
         }
       }, 2000);
     }
   }, [shipRef, stageClearEffectRef, hyperSpaceJumpEffectRef, starsRef, startNewStage]);
 
-  const startNewStage = useCallback((stageNumber, asteroidCount) => {
-    stageRef.current = stageNumber;
-    baseAsteroidCountRef.current = asteroidCount;
-    stageClearedRef.current = false;
-
-    // Clear bullets
-    bulletsRef.current = [];
-    setBulletCount(0);
-
-    // Reset and re-center ship with zero velocity
-    const ship = shipRef.current;
-    if (ship) {
-      ship.x = WORLD_WIDTH / 2;
-      ship.y = WORLD_HEIGHT / 2;
-      ship.vx = 0;
-      ship.vy = 0;
-    }
-
-    // Initialize new asteroids for the stage
-    initializeAsteroids(asteroidCount);
-
-    // Regenerate starfield for variety
-    generateStarfield();
-
-    // Update UI stage indicator
-    setUiState(prev => ({ ...prev, stage: stageNumber }));
-  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
-
   return {
     // refs
     starsRef,
     asteroidsRef,
     asteroidCountsRef,
     xpRef,
     levelRef,
     stageRef,
     baseAsteroidCountRef,
     stageClearedRef,
     // functions
     generateStarfield,
     initializeAsteroids,
     xpNeededForNextLevel,
     triggerLevelUp,
     addXp,
     updateAsteroidCounts,
     startNewStage,
   };
 }
 
EOF
)

-----
Run 4

Summary

Reordered the startNewStage and updateAsteroidCounts callbacks so the module no longer throws a temporal-dead-zone ReferenceError during initialization, allowing the render loop to start and the game screen to display properly.

Renamed the HUD component file to Hud.jsx to match the existing import casing on case-sensitive systems, preventing build-time resolution failures.

Updated the bullet-limit integration test to select the Waves mode button by its accessible role, keeping the suite stable with the overlayâ€™s current markup.

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/App.test.jsx b/src/App.test.jsx
index e3952855578eb4251554f9c6cdd23cc0786cc5f5..92ae63fbf5197732fa96f26e19055653b9ef4f40 100644
--- a/src/App.test.jsx
+++ b/src/App.test.jsx
@@ -1,32 +1,32 @@
 import { render, fireEvent, screen, act } from '@testing-library/react';
 import { describe, it, expect, vi } from 'vitest';
 import App from './App.jsx';
 import { BULLET_FIRE_RATE, MAX_BULLETS } from './utils/constants.js';
 
 describe('bullet firing limits', () => {
   it('caps bullets at MAX_BULLETS when holding fire', () => {
     vi.useFakeTimers();
     vi.setSystemTime(0);
 
     render(<App />);
 
     // Click StartOverlay "Waves" button to start
-    const wavesButton = screen.getByText(/waves/i);
+    const wavesButton = screen.getByRole('button', { name: /^waves/i });
     fireEvent.click(wavesButton);
 
     // Hold Space to fire
     fireEvent.keyDown(window, { code: 'Space' });
 
     for (let i = 0; i < MAX_BULLETS + 2; i++) {
       act(() => {
         vi.advanceTimersByTime(BULLET_FIRE_RATE);
       });
     }
 
     const count = Number(screen.getByTestId('bullet-count').textContent);
     expect(count).toBe(MAX_BULLETS);
 
     fireEvent.keyUp(window, { code: 'Space' });
     vi.useRealTimers();
   });
 });
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/hooks/useGameWorld.js b/src/hooks/useGameWorld.js
index f7a5be805fc817d2b7f5048fea01ef725aa0fa4f..a705ab9cdf9b736cc6afb2b4934d7a03d527a266 100644
--- a/src/hooks/useGameWorld.js
+++ b/src/hooks/useGameWorld.js
@@ -61,108 +61,108 @@ export function useGameWorld({
   const xpNeededForNextLevel = useCallback((level) => Math.round(XP_LEVEL_BASE * Math.pow(XP_LEVEL_GROWTH, Math.max(0, level - 1))), []);
 
   const triggerLevelUp = useCallback((newLevel) => {
     levelRef.current = newLevel;
     setUiState(prev => ({ ...prev, level: newLevel }));
   }, [setUiState]);
 
   const addXp = useCallback((amount) => {
     xpRef.current += amount;
 
     // Check for level up
     const currentLevel = levelRef.current;
     const requiredXp = xpNeededForNextLevel(currentLevel);
 
     if (xpRef.current >= requiredXp) {
       const newLevel = currentLevel + 1;
       // Remove used XP for next level calculation
       xpRef.current -= requiredXp;
       triggerLevelUp(newLevel);
     }
 
     // Update UI
     setUiState(prev => ({ ...prev, xp: xpRef.current }));
   }, [xpNeededForNextLevel, triggerLevelUp, setUiState]);
 
+  const startNewStage = useCallback((stageNumber, asteroidCount) => {
+    stageRef.current = stageNumber;
+    baseAsteroidCountRef.current = asteroidCount;
+    stageClearedRef.current = false;
+
+    // Clear bullets
+    bulletsRef.current = [];
+    setBulletCount(0);
+
+    // Reset and re-center ship with zero velocity
+    const ship = shipRef.current;
+    if (ship) {
+      ship.x = WORLD_WIDTH / 2;
+      ship.y = WORLD_HEIGHT / 2;
+      ship.vx = 0;
+      ship.vy = 0;
+    }
+
+    // Initialize new asteroids for the stage
+    initializeAsteroids(asteroidCount);
+
+    // Regenerate starfield for variety
+    generateStarfield();
+
+    // Update UI stage indicator
+    setUiState(prev => ({ ...prev, stage: stageNumber }));
+  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
+
   const updateAsteroidCounts = useCallback(() => {
     const counts = { large: 0, medium: 0, small: 0 };
 
     asteroidsRef.current.forEach(asteroid => {
       if (asteroid.size === ASTEROID_SIZE_LARGE) counts.large++;
       else if (asteroid.size === ASTEROID_SIZE_MEDIUM) counts.medium++;
       else if (asteroid.size === ASTEROID_SIZE_SMALL) counts.small++;
     });
 
     asteroidCountsRef.current = counts;
 
     // Check if stage is cleared (no asteroids left)
     const totalAsteroids = counts.large + counts.medium + counts.small;
     if (totalAsteroids === 0 && !stageClearedRef.current) {
       stageClearedRef.current = true;
       // Trigger stage clear effect
       stageClearEffectRef.current.trigger();
 
       // After a delay, start hyperspace jump to next stage
       setTimeout(() => {
         if (shipRef.current && hyperSpaceJumpEffectRef.current) {
           hyperSpaceJumpEffectRef.current.trigger(
             shipRef.current.angle,
             stageRef.current,
             baseAsteroidCountRef.current + Math.floor(stageRef.current * 0.5),
             (stageNumber, asteroidCount) => {
               setTimeout(() => startNewStage(stageNumber, asteroidCount), 100);
             }
           );
           hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
         }
       }, 2000);
     }
   }, [shipRef, stageClearEffectRef, hyperSpaceJumpEffectRef, starsRef, startNewStage]);
 
-  const startNewStage = useCallback((stageNumber, asteroidCount) => {
-    stageRef.current = stageNumber;
-    baseAsteroidCountRef.current = asteroidCount;
-    stageClearedRef.current = false;
-
-    // Clear bullets
-    bulletsRef.current = [];
-    setBulletCount(0);
-
-    // Reset and re-center ship with zero velocity
-    const ship = shipRef.current;
-    if (ship) {
-      ship.x = WORLD_WIDTH / 2;
-      ship.y = WORLD_HEIGHT / 2;
-      ship.vx = 0;
-      ship.vy = 0;
-    }
-
-    // Initialize new asteroids for the stage
-    initializeAsteroids(asteroidCount);
-
-    // Regenerate starfield for variety
-    generateStarfield();
-
-    // Update UI stage indicator
-    setUiState(prev => ({ ...prev, stage: stageNumber }));
-  }, [initializeAsteroids, generateStarfield, bulletsRef, setBulletCount, shipRef, setUiState]);
-
   return {
     // refs
     starsRef,
     asteroidsRef,
     asteroidCountsRef,
     xpRef,
     levelRef,
     stageRef,
     baseAsteroidCountRef,
     stageClearedRef,
     // functions
     generateStarfield,
     initializeAsteroids,
     xpNeededForNextLevel,
     triggerLevelUp,
     addXp,
     updateAsteroidCounts,
     startNewStage,
   };
 }
 
EOF
)