RUN 1

Summary

Routed a shared minimap canvas ref through App so the render loop can refresh the minimap in step with the main scene on every frame.

Simplified the HUD to size the minimap canvas from responsive layout metrics while leaving drawing responsibilities to the central renderer.

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/App.jsx b/src/App.jsx
index 084d71f2e2dc96c482d6b3aa37a05607e23ada7c..8400e2523844d59b35f67ae8094770489bbb4a86 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -1,52 +1,53 @@
 import { useRef, useEffect, useState, useCallback } from 'react';
 import { Ship } from './components/Ship.js';
 import { CANVAS_WIDTH, CANVAS_HEIGHT, CROSSHAIR_SIZE, INITIAL_LIVES, WORLD_WIDTH, WORLD_HEIGHT } from './utils/constants.js';
 import { LevelUpEffect } from './effects/LevelUpEffect.js';
 import { StageClearEffect } from './effects/StageClearEffect.js';
 import { HyperSpaceJumpEffect } from './effects/HyperSpaceJumpEffect.js';
 import { DeathExplosion } from './effects/DeathExplosion.js';
 import { Camera } from './utils/camera.js';
 import { useGameWorld } from './hooks/useGameWorld.js';
 import { useGameSession } from './hooks/useGameSession.js';
 import { useGameControls } from './hooks/useGameControls.js';
 import { useGameLogic } from './hooks/useGameLogic.js';
 import { useResponsiveLayout } from './hooks/useResponsiveLayout.js';
 import { useGameLoop } from './hooks/useGameLoop.js';
 import { useGameTimer } from './hooks/useGameTimer.js';
 import { renderScene } from './render/gameRenderer.js';
 import PauseOverlay from './components/PauseOverlay.jsx';
 import StartOverlay from './components/StartOverlay.jsx';
 import LifeLostOverlay from './components/LifeLostOverlay.jsx';
-import Hud from './components/Hud.jsx';
+import Hud from './components/HUD.jsx';
 import './App.css';
 
 function App() {
   const canvasRef = useRef(null);
   const playAreaRef = useRef(null);
   const canvasWidthRef = useRef(CANVAS_WIDTH);
   const canvasHeightRef = useRef(CANVAS_HEIGHT);
+  const minimapCanvasRef = useRef(null);
   const shipRef = useRef(new Ship(WORLD_WIDTH / 2, WORLD_HEIGHT / 2));
   const cameraRef = useRef(new Camera());
   const bulletsRef = useRef([]);
   const keysRef = useRef({});
   const mousePositionRef = useRef({ x: 0, y: 0 });
   const mouseScreenRef = useRef({ x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 });
   const isMouseDownRef = useRef(false);
   const isPausedRef = useRef(false);
   const testingModeRef = useRef(false);
   const gameStartedRef = useRef(false);
   const gameOverRef = useRef(false);
   const scoreRef = useRef(0);
   const livesRef = useRef(INITIAL_LIVES);
   const lastShotTimeRef = useRef(0);
   const levelUpEffectRef = useRef(new LevelUpEffect());
   const stageClearEffectRef = useRef(new StageClearEffect());
   const hyperSpaceJumpEffectRef = useRef(new HyperSpaceJumpEffect());
   const deathExplosionRef = useRef(new DeathExplosion());
   const [uiState, setUiState] = useState({
     score: 0, lives: INITIAL_LIVES, xp: 0, level: 1, gameOver: false,
     gameStarted: false, isPaused: false, testingMode: false, mode: null
   });
   const [bulletCount, setBulletCount] = useState(0);
   const [lifeLostVisible, setLifeLostVisible] = useState(false);
 
diff --git a/src/App.jsx b/src/App.jsx
index 084d71f2e2dc96c482d6b3aa37a05607e23ada7c..8400e2523844d59b35f67ae8094770489bbb4a86 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -79,67 +80,69 @@ function App() {
 
   const { metaLayout } = useResponsiveLayout({ canvasRef, playAreaRef, canvasWidthRef, canvasHeightRef });
 
   const { start, pause, reset, formattedTime } = useGameTimer();
 
   const { initializeAsteroids, generateStarfield } = world;
 
   useEffect(() => {
     initializeAsteroids();
     generateStarfield();
   }, [initializeAsteroids, generateStarfield]);
 
   useEffect(() => {
     const active = uiState.mode === 'survival' && uiState.gameStarted && !uiState.isPaused && !uiState.gameOver;
     active ? start() : pause();
   }, [uiState.mode, uiState.gameStarted, uiState.isPaused, uiState.gameOver, start, pause]);
 
   useEffect(() => {
     if (!uiState.gameStarted || uiState.mode !== 'survival') reset();
   }, [uiState.gameStarted, uiState.mode, reset]);
   const render = useCallback(() => {
     renderScene({
       canvasRef,
       canvasWidthRef,
       canvasHeightRef,
+      minimapCanvasRef,
       cameraRef,
       starsRef: world.starsRef,
       shipRef,
       asteroidsRef: world.asteroidsRef,
       bulletsRef,
       mousePositionRef,
       gameStartedRef,
       levelUpEffectRef,
       stageClearEffectRef,
       hyperSpaceJumpEffectRef,
       deathExplosionRef,
       CROSSHAIR_SIZE,
     });
   }, [
     canvasRef,
     canvasWidthRef,
     canvasHeightRef,
+    minimapCanvasRef,
     cameraRef,
     world.starsRef,
     shipRef,
     world.asteroidsRef,
     bulletsRef,
     mousePositionRef,
     gameStartedRef,
     levelUpEffectRef,
     stageClearEffectRef,
     hyperSpaceJumpEffectRef,
     deathExplosionRef,
   ]);
   useGameLoop({ update, render, setUiState, scoreRef, livesRef, gameOverRef, xpRef: world.xpRef, levelRef: world.levelRef });
 
   return (
     <div className="app">
       <div className="play-area" ref={playAreaRef}>
         <canvas
           ref={canvasRef}
           width={1200}
           height={900}
           className="game-canvas"
           role="img"
           aria-label="Asteroids play area"
         />
diff --git a/src/App.jsx b/src/App.jsx
index 084d71f2e2dc96c482d6b3aa37a05607e23ada7c..8400e2523844d59b35f67ae8094770489bbb4a86 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -157,39 +160,38 @@ function App() {
             onResume={session.handleResume}
             onExit={session.handleExitToMenu}
           />
         )}
 
         <div data-testid="bullet-count" style={{ display: 'none' }}>{bulletCount}</div>
 
         {uiState.gameOver && (
           <div style={{
             position: 'absolute',
             top: '20%',
             left: '50%',
             transform: 'translateX(-50%)',
             color: 'white'
           }}>
             <div style={{ textAlign: 'center', marginBottom: 12, fontSize: 24 }}>Game Over</div>
             {uiState.gameStarted && <button onClick={session.startGame}>New Game</button>}
           </div>
         )}
       </div>
 
       <Hud
         uiState={uiState}
         metaLayout={metaLayout}
         world={world}
-        shipRef={shipRef}
-        cameraRef={cameraRef}
         formattedTime={formattedTime}
+        minimapCanvasRef={minimapCanvasRef}
       />
       {uiState.testingMode && (
         <div className="testing-mode-indicator">
           Testing Mode ON
         </div>
       )}
     </div>
   );
 }
 
 export default App;
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/components/HUD.jsx b/src/components/HUD.jsx
index 5dab7aebc3aa5d63fe110149ace84691e1293131..7e2a9e3a2e330ee8a94fdc6a4bc8b5edcfedd1b9 100644
--- a/src/components/HUD.jsx
+++ b/src/components/HUD.jsx
@@ -1,39 +1,36 @@
 import { useRef, useEffect, useCallback } from 'react';
-import { Minimap } from './Minimap.js';
 
 export default function Hud({
   uiState,
   metaLayout,
   world,
-  shipRef,
-  cameraRef,
-  formattedTime
+  formattedTime,
+  minimapCanvasRef
 }) {
   const xpBarCanvasRef = useRef(null);
-  const minimapCanvasRef = useRef(null);
-  const { xpNeededForNextLevel, asteroidsRef, stageRef } = world;
+  const { xpNeededForNextLevel, stageRef } = world;
 
   // XP Bar Rendering Logic
   const renderXpBar = useCallback(() => {
     const canvas = xpBarCanvasRef.current;
     if (!canvas) return;
     const ctx = canvas.getContext('2d');
     if (!ctx) return;
 
     const w = canvas.width;
     const h = canvas.height;
 
     ctx.clearRect(0, 0, w, h);
 
     // Dark background
     ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
     ctx.fillRect(0, 0, w, h);
 
     // XP progress calculation
     const currentXp = uiState.xp || 0;
     const totalXpNeeded = xpNeededForNextLevel(uiState.level);
     const progress = Math.min(currentXp / totalXpNeeded, 1);
 
     // Background bar
     ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
     ctx.fillRect(0, 0, w, h);
diff --git a/src/components/HUD.jsx b/src/components/HUD.jsx
index 5dab7aebc3aa5d63fe110149ace84691e1293131..7e2a9e3a2e330ee8a94fdc6a4bc8b5edcfedd1b9 100644
--- a/src/components/HUD.jsx
+++ b/src/components/HUD.jsx
@@ -45,97 +42,76 @@ export default function Hud({
       gradient.addColorStop(0.5, '#8BC34A');
       gradient.addColorStop(1, '#CDDC39');
       ctx.fillStyle = gradient;
       ctx.fillRect(0, 0, w * progress, h);
     }
 
     // White bottom border
     ctx.strokeStyle = 'white';
     ctx.lineWidth = 2;
     ctx.beginPath();
     ctx.moveTo(0, h - 1);
     ctx.lineTo(w, h - 1);
     ctx.stroke();
 
     // XP text overlay (centered)
     ctx.fillStyle = 'white';
     ctx.font = 'bold 14px Arial';
     ctx.textAlign = 'center';
     ctx.textBaseline = 'middle';
     ctx.shadowColor = 'rgba(0,0,0,0.8)';
     ctx.shadowBlur = 4;
     const xpText = `${currentXp} / ${totalXpNeeded} XP`;
     ctx.fillText(xpText, w / 2, h / 2);
   }, [uiState.level, uiState.xp, xpNeededForNextLevel]);
 
-  // Minimap Rendering Logic
-  const renderMinimap = useCallback(() => {
-    const canvas = minimapCanvasRef.current;
-    if (!canvas) return;
-    const ctx = canvas.getContext('2d');
-    if (!ctx) return;
-    Minimap.draw(ctx, shipRef.current, asteroidsRef.current, cameraRef.current);
-  }, [asteroidsRef, cameraRef, shipRef]);
-
   // Canvas Setup and Rendering
   useEffect(() => {
     // Setup XP bar canvas dimensions
     const xpBarCanvas = xpBarCanvasRef.current;
     if (xpBarCanvas && metaLayout.playWidth) {
       xpBarCanvas.width = metaLayout.playWidth + 4; // Match full HUD width
       xpBarCanvas.height = 20;
       xpBarCanvas.style.width = `100%`;
       xpBarCanvas.style.height = '20px';
     }
 
     // Setup minimap canvas dimensions
-    const minimapCanvas = minimapCanvasRef.current;
-    if (minimapCanvas) {
-      // Calculate minimap size to fill available HUD space
-      const hudHeight = 120; // from CSS
-      const xpBarHeight = 20;
-      const availableHeight = hudHeight - xpBarHeight - 4; // 4px for borders
-      const worldAspect = 8000 / 5500; // width/height ratio
-      const minimapHeight = availableHeight;
-      const minimapWidth = minimapHeight * worldAspect;
-
-      minimapCanvas.width = minimapWidth;
-      minimapCanvas.height = minimapHeight;
-      minimapCanvas.style.width = `${minimapWidth}px`;
-      minimapCanvas.style.height = `${minimapHeight}px`;
+    const minimapCanvas = minimapCanvasRef?.current;
+    if (minimapCanvas && metaLayout.minimapWidth && metaLayout.minimapHeight) {
+      minimapCanvas.width = metaLayout.minimapWidth;
+      minimapCanvas.height = metaLayout.minimapHeight;
+      minimapCanvas.style.width = `${metaLayout.minimapWidth}px`;
+      minimapCanvas.style.height = `${metaLayout.minimapHeight}px`;
     }
-  }, [metaLayout.playWidth]);
+  }, [metaLayout.playWidth, metaLayout.minimapWidth, metaLayout.minimapHeight, minimapCanvasRef]);
 
   // Render canvases when data changes
   useEffect(() => {
     renderXpBar();
   }, [renderXpBar]);
 
-  useEffect(() => {
-    renderMinimap();
-  }, [renderMinimap, metaLayout.playWidth]);
-
   if (!metaLayout.playWidth) return null;
 
   return (
     <div
       className="hud-container"
       style={{
         width: `${metaLayout.playWidth + 4}px`,
         left: `${metaLayout.playX}px`,
         top: `${metaLayout.playY + metaLayout.playHeight + 5}px`
       }}
     >
       <canvas ref={xpBarCanvasRef} className="hud-xpbar" />
       <div className="hud-content">
         <div className="hud-left">
           <div className="hud-stat">XP: {uiState.xp}/{xpNeededForNextLevel(uiState.level)}</div>
           <div className="hud-stat">Level: {uiState.level}</div>
           <div className="hud-stat">Lives: {uiState.lives}</div>
         </div>
 
         <canvas
           ref={minimapCanvasRef}
           className="hud-minimap"
         />
 
         <div className="hud-right">
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/render/gameRenderer.js b/src/render/gameRenderer.js
index c4383ea3231c6aafce8384e8249e55d92c90d948..b6ef88c7ae0c5baa962d39670682940ed3fcc8de 100644
--- a/src/render/gameRenderer.js
+++ b/src/render/gameRenderer.js
@@ -1,32 +1,34 @@
 // Pure functions - no React imports
 
+import { Minimap } from '../components/Minimap.js';
 
 export function renderScene({
   canvasRef,
   canvasWidthRef,
   canvasHeightRef,
+  minimapCanvasRef,
   cameraRef,
   starsRef,
   shipRef,
   asteroidsRef,
   bulletsRef,
   mousePositionRef,
   gameStartedRef,
   levelUpEffectRef,
   stageClearEffectRef,
   hyperSpaceJumpEffectRef,
   deathExplosionRef,
   CROSSHAIR_SIZE,
 }) {
   const canvas = canvasRef.current;
   if (!canvas) return;
 
   let ctx;
   try {
     ctx = canvas.getContext('2d');
   } catch {}
   if (!ctx) return;
   const canvasWidth = canvasWidthRef.current || 1200;
   const canvasHeight = canvasHeightRef.current || 900;
   ctx.clearRect(0, 0, canvasWidth, canvasHeight);
 
diff --git a/src/render/gameRenderer.js b/src/render/gameRenderer.js
index c4383ea3231c6aafce8384e8249e55d92c90d948..b6ef88c7ae0c5baa962d39670682940ed3fcc8de 100644
--- a/src/render/gameRenderer.js
+++ b/src/render/gameRenderer.js
@@ -108,26 +110,37 @@ export function renderScene({
       ctx.restore();
     }
   });
 
   // Draw crosshair at mouse position
   if (gameStartedRef.current) {
     const mousePos = mousePositionRef.current;
     const screenPos = camera.worldToScreen(mousePos.x, mousePos.y, canvasWidth, canvasHeight);
     ctx.strokeStyle = 'white';
     ctx.lineWidth = 2;
     ctx.beginPath();
     // Horizontal line
     ctx.moveTo(screenPos.x - CROSSHAIR_SIZE, screenPos.y);
     ctx.lineTo(screenPos.x + CROSSHAIR_SIZE, screenPos.y);
     // Vertical line
     ctx.moveTo(screenPos.x, screenPos.y - CROSSHAIR_SIZE);
     ctx.lineTo(screenPos.x, screenPos.y + CROSSHAIR_SIZE);
     ctx.stroke();
   }
 
   // Draw effects (overlay)
   levelUpEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
   stageClearEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
   hyperSpaceJumpEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
   deathExplosionRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
-}
+
+  const minimapCanvas = minimapCanvasRef?.current;
+  if (minimapCanvas) {
+    let minimapCtx;
+    try {
+      minimapCtx = minimapCanvas.getContext('2d');
+    } catch {}
+    if (minimapCtx) {
+      Minimap.draw(minimapCtx, shipRef.current, asteroidsRef.current, camera);
+    }
+  }
+}
 
EOF
)

------
RUN 2

Summary

Added a requestAnimationFrame-driven redraw loop in the HUD so the minimap stays in sync with gameplay while avoiding extra work when paused or idle.

Renamed the HUD component to Hud.jsx to match the import casing on case-sensitive systems.

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/components/HUD.jsx b/src/components/Hud.jsx
index 5dab7aebc3aa5d63fe110149ace84691e1293131..58a47e19eb6e1ab7ff18d8c660060b81ededa02a 100644
--- a/src/components/HUD.jsx
+++ b/src/components/Hud.jsx
@@ -89,52 +89,77 @@ export default function Hud({
 
     // Setup minimap canvas dimensions
     const minimapCanvas = minimapCanvasRef.current;
     if (minimapCanvas) {
       // Calculate minimap size to fill available HUD space
       const hudHeight = 120; // from CSS
       const xpBarHeight = 20;
       const availableHeight = hudHeight - xpBarHeight - 4; // 4px for borders
       const worldAspect = 8000 / 5500; // width/height ratio
       const minimapHeight = availableHeight;
       const minimapWidth = minimapHeight * worldAspect;
 
       minimapCanvas.width = minimapWidth;
       minimapCanvas.height = minimapHeight;
       minimapCanvas.style.width = `${minimapWidth}px`;
       minimapCanvas.style.height = `${minimapHeight}px`;
     }
   }, [metaLayout.playWidth]);
 
   // Render canvases when data changes
   useEffect(() => {
     renderXpBar();
   }, [renderXpBar]);
 
   useEffect(() => {
+    let frameId;
+
+    const animateMinimap = () => {
+      renderMinimap();
+      frameId = requestAnimationFrame(animateMinimap);
+    };
+
+    // Always draw once so the minimap reflects the latest state even when idle
     renderMinimap();
-  }, [renderMinimap, metaLayout.playWidth]);
+
+    const shouldAnimate = uiState.gameStarted && !uiState.isPaused && !uiState.gameOver;
+    if (shouldAnimate) {
+      frameId = requestAnimationFrame(animateMinimap);
+    }
+
+    return () => {
+      if (frameId) {
+        cancelAnimationFrame(frameId);
+      }
+    };
+  }, [
+    renderMinimap,
+    metaLayout.playWidth,
+    uiState.gameStarted,
+    uiState.isPaused,
+    uiState.gameOver,
+  ]);
 
   if (!metaLayout.playWidth) return null;
 
   return (
     <div
       className="hud-container"
       style={{
         width: `${metaLayout.playWidth + 4}px`,
         left: `${metaLayout.playX}px`,
         top: `${metaLayout.playY + metaLayout.playHeight + 5}px`
       }}
     >
       <canvas ref={xpBarCanvasRef} className="hud-xpbar" />
       <div className="hud-content">
         <div className="hud-left">
           <div className="hud-stat">XP: {uiState.xp}/{xpNeededForNextLevel(uiState.level)}</div>
           <div className="hud-stat">Level: {uiState.level}</div>
           <div className="hud-stat">Lives: {uiState.lives}</div>
         </div>
 
         <canvas
           ref={minimapCanvasRef}
           className="hud-minimap"
         />
 
 
EOF
)
