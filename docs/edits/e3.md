1. Input and pointer handling tightly coupled in App.jsx
Keyboard and mouse listeners (e.g., handleKeyDown, handleMouseMove, handleWheel) are embedded directly inside App.jsx, making the component responsible for low-level event management in addition to rendering logic

Suggested task
Create dedicated `useInput` hook


// Handle pointer lock and mouse/keyboard input
useEffect(() => {
  const handleKeyDown = (e) => {
    if (['KeyW', 'KeyS', 'Space', 'Escape', 'Tab', 'Digit1', 'Digit2', 'Digit3'].includes(e.code)) {
      e.preventDefault();
    }

    keysRef.current[e.code] = true;
    
    // Handle pause toggle with ESC
    if (e.code === 'Escape' && gameStartedRef.current && !gameOverRef.current) {
      isPausedRef.current = !isPausedRef.current;
      setUiState(prev => ({ ...prev, isPaused: isPausedRef.current }));
    }
    
    // Toggle testing mode with Tab
    if (e.code === 'Tab') {
      testingModeRef.current = !testingModeRef.current;
      setUiState(prev => ({ ...prev, testingMode: testingModeRef.current }));
    }
    
    // Testing mode effect triggers
    if (testingModeRef.current && gameStartedRef.current) {
      if (e.code === 'Digit1') {
        triggerLevelUp(levelRef.current);
      }
      if (e.code === 'Digit2') {
        stageClearEffectRef.current.trigger();
      }
      if (e.code === 'Digit3') {
        const ship = shipRef.current;
        if (ship) {
          hyperSpaceJumpEffectRef.current.trigger(
            ship.angle,
            stageRef.current,
            baseAsteroidCountRef.current,
            startNewStage
          );
          hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
        }
      }
      if (e.code === 'Digit4') {
        // Trigger game over for testing
        gameOverRef.current = true;
        stopTimer();
        setUiState(prev => ({ 
          ...prev, 
          gameOver: true,
          finalStats: {
            wave: stageRef.current,
            level: levelRef.current,
            score: scoreRef.current,
            timeString: formatTime(elapsedTimeRef.current)
          }
        }));
      }
      if (e.code === 'Digit5') {
        // Trigger death effect for testing
        const ship = shipRef.current;
        if (ship) {
          console.log('Test trigger: Death effect at ship position', ship.x, ship.y);
          deathEffectRef.current.trigger(ship.x, ship.y);
          livesRef.current = 0; // Set lives to 0 to trigger game over sequence
          console.log('Death effect active:', deathEffectRef.current.active);
        }
      }
    }
  };
  
  const handleKeyUp = (e) => {
    keysRef.current[e.code] = false;
  };


  const handleMouseMove = (e) => {
    if (canvasRef.current && gameStartedRef.current) {
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      const camera = cameraRef.current;
      
      // Get mouse position relative to canvas
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;
      // Persist screen-space position for idle reprojection
      mouseScreenRef.current.x = canvasX;
      mouseScreenRef.current.y = canvasY;
      
      // Convert canvas coordinates to world coordinates
      const worldPos = camera.screenToWorld(canvasX, canvasY, canvas.width, canvas.height);
      
      mousePositionRef.current.x = worldPos.x;
      mousePositionRef.current.y = worldPos.y;
    }
  };

  const handleMouseDown = (e) => {
    if (e.button === 0 && gameStartedRef.current && !gameOverRef.current) {
      isMouseDownRef.current = true;
      // fire immediately; update loop will handle steady cadence
      shootBullet(true);
    }
  };

  const handleMouseUp = (e) => {
    if (e.button === 0) {
      isMouseDownRef.current = false;
    }
  };

  const handleWheel = (e) => {
    e.preventDefault();
    const camera = cameraRef.current;
    const zoomDelta = e.deltaY > 0 ? ZOOM_SPEED : -ZOOM_SPEED;
    camera.setZoom(camera.targetZoom + zoomDelta);
  };

  const handleCanvasClick = (e) => {
    if (hyperSpaceJumpEffectRef.current.phase === 'waiting') {
      hyperSpaceJumpEffectRef.current.startNewStage();
    }
  };
  
  if (canvasRef.current) {
    canvasRef.current.addEventListener('click', handleCanvasClick);
  }

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mousedown', handleMouseDown);
  document.addEventListener('mouseup', handleMouseUp);
  document.addEventListener('wheel', handleWheel);
  
  return () => {
    window.removeEventListener('keydown', handleKeyDown);
    window.removeEventListener('keyup', handleKeyUp);
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mousedown', handleMouseDown);
    document.removeEventListener('mouseup', handleMouseUp);
    document.removeEventListener('wheel', handleWheel);
    if (canvasRef.current) {
      canvasRef.current.removeEventListener('click', handleCanvasClick);
    }
  };
}, [triggerLevelUp, startNewStage]);



——————



2. Game loop and rendering logic embedded in App.jsx
The main update and render cycle, plus the requestAnimationFrame loop, are all defined inline, blending core game mechanics with UI concerns

Suggested task
Extract game loop into `useGameLoop`


const update = useCallback(() => {
  // ALWAYS update death effect, even during pause
  if (deathEffectRef.current.active) {
    deathEffectRef.current.update();
  }
  
  // Check for game over after death effect completes
  if (deathEffectRef.current.isDone() && livesRef.current <= 0 && !gameOverRef.current) {
    deathSequenceActiveRef.current = false; // Unpause for game over screen
    gameOverRef.current = true;
    stopTimer();
    setUiState(prev => ({ 
      ...prev, 
      gameOver: true,
      finalStats: {
        wave: stageRef.current,
        level: levelRef.current,
        score: scoreRef.current,
        timeString: formatTime(elapsedTimeRef.current)
      }
    }));
    deathEffectRef.current.reset();
  }
  
  // Now check pause conditions (but exclude death effect from the check)
  if (gameOverRef.current || !gameStartedRef.current || isPausedRef.current || deathSequenceActiveRef.current) return;

  // Update camera zoom
  const camera = cameraRef.current;
  camera.updateZoom();

  // Update ship - aims at crosshair, moves with W/S
  const keys = keysRef.current;
  const ship = shipRef.current;
  
  if (deathEffectRef.current.active) {
    // Skip ship update during death effect
  } else {
    // Reproject last known screen mouse into world space even if mouse is idle.
    // This prevents the crosshair from becoming stale when the camera moves.
    const canvasWidth = canvasWidthRef.current || CANVAS_WIDTH;
    const canvasHeight = canvasHeightRef.current || CANVAS_HEIGHT;
    const reproj = camera.screenToWorld(
      mouseScreenRef.current.x,
      mouseScreenRef.current.y,
      canvasWidth,
      canvasHeight
    );
    mousePositionRef.current.x = reproj.x;
    mousePositionRef.current.y = reproj.y;
    const mousePos = mousePositionRef.current;
    
    // Calculate angle to mouse crosshair
    const dx = mousePos.x - ship.x;
    const dy = mousePos.y - ship.y;
    ship.angle = Math.atan2(dy, dx);
    
    // W/S movement controls
    if (keys.KeyW) {
      ship.vx += Math.cos(ship.angle) * ship.speed;
      ship.vy += Math.sin(ship.angle) * ship.speed;
    }
    
    // Apply velocity and friction
    ship.x += ship.vx;
    ship.y += ship.vy;
    
    // S key brakes (slows down to zero, no reverse)
    if (keys.KeyS) {
      ship.vx *= SHIP_DECELERATION;
      ship.vy *= SHIP_DECELERATION;
    } else {
      ship.vx *= SHIP_FRICTION;
      ship.vy *= SHIP_FRICTION;
    }
    wrapPosition(ship); // World wrapping

    // Update camera to follow ship
    camera.followShip(ship.x, ship.y, canvasWidth, canvasHeight);
  }

  // Update asteroids
  asteroidsRef.current.forEach((asteroid) => {
    asteroid.update();
    wrapPosition(asteroid); // World wrapping
  });

  // Update bullets
  bulletsRef.current.forEach((bullet) => {
    bullet.update();
    wrapPosition(bullet); // World wrapping
  });
  bulletsRef.current = bulletsRef.current.filter((bullet) => !bullet.isExpired());
  setBulletCount(bulletsRef.current.length);

  // Unified, smooth firing cadence for Space or LMB hold
  const currentTime = Date.now();
  const isFiring = keys.Space || isMouseDownRef.current;
  if (
    isFiring &&
    currentTime - lastShotTimeRef.current >= BULLET_FIRE_RATE &&
    bulletsRef.current.length < MAX_BULLETS
  ) {
    bulletsRef.current.push(new Bullet(ship.x, ship.y, ship.angle));
    lastShotTimeRef.current = currentTime;
    setBulletCount(bulletsRef.current.length);
  }

  // Collisions
  let asteroidsToRemove = [];
  let bulletsToRemove = [];
  let newAsteroids = [];

  bulletsRef.current.forEach((bullet, bi) => {
    asteroidsRef.current.forEach((asteroid, ai) => {
      if (checkCollision(bullet, asteroid)) {
        if (!bulletsToRemove.includes(bi)) bulletsToRemove.push(bi);
        if (!asteroidsToRemove.includes(ai)) asteroidsToRemove.push(ai);
        newAsteroids.push(...asteroid.split());
        scoreRef.current += SCORE_PER_ASTEROID;
        addXp(XP_PER_ASTEROID);
      }
    });
  });

  // Remove collided items (iterate backwards to avoid index issues)
  bulletsToRemove.sort((a, b) => b - a).forEach(index => {
    bulletsRef.current.splice(index, 1);
  });
  asteroidsToRemove.sort((a, b) => b - a).forEach(index => {
    asteroidsRef.current.splice(index, 1);
  });
  
  // Add new asteroids from splits
  asteroidsRef.current.push(...newAsteroids);

  // Ship collision - only check if not invulnerable and not in death sequence
  if (!deathSequenceActiveRef.current && shipRef.current && !shipRef.current.invulnerable) {
    let shipCollisionIndex = -1;
    let shipCollisionSplits = [];
    
    asteroidsRef.current.forEach((asteroid, ai) => {
      if (checkCollision(shipRef.current, asteroid)) {
        livesRef.current -= 1;
        shipCollisionSplits = asteroid.split();
        shipCollisionIndex = ai;
        
        // Pause game immediately
        deathSequenceActiveRef.current = true;
        pauseStartRef.current = Date.now(); // Track when pause started
        
        // Trigger death effect
        deathEffectRef.current.trigger(shipRef.current.x, shipRef.current.y);
        
        if (livesRef.current > 0) {
          // Show death overlay after explosion
          setTimeout(() => {
            setUiState(prev => ({ 
              ...prev, 
              showDeathOverlay: true,
              lives: livesRef.current
            }));
          }, 1500);
        }
      }
    });
    
    // Remove asteroid and add splits
    if (shipCollisionIndex >= 0) {
      asteroidsRef.current.splice(shipCollisionIndex, 1);
      asteroidsRef.current.push(...shipCollisionSplits);
    }
  }

  // Update invulnerability
  if (shipRef.current && shipRef.current.invulnerable) {
    if (Date.now() > shipRef.current.invulnerableUntil) {
      shipRef.current.invulnerable = false;
    }
  }

  // Level-up effect update
  levelUpEffectRef.current.update();
  stageClearEffectRef.current.update();
  hyperSpaceJumpEffectRef.current.update();
  hyperSpaceJumpEffectRef.current.updateStars(starsRef.current);
  
  // Update asteroid counts for active tracking
  updateAsteroidCounts();
}, [updateAsteroidCounts]);

const renderMinimap = useCallback(() => {
  const minimapCanvas = minimapCanvasRef.current;
  if (!minimapCanvas) return;
  const ctx = minimapCanvas.getContext('2d');
  if (!ctx) return; // jsdom/test environment safeguard
  Minimap.draw(ctx, shipRef.current, asteroidsRef.current, cameraRef.current);
}, []);

const renderXpBar = useCallback(() => {
  const canvas = xpBarCanvasRef.current;
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);
  // Solid black box with golden border
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);
  ctx.strokeStyle = '#d4af37';
  ctx.lineWidth = 2;
  ctx.strokeRect(0.5, 0.5, w - 1, h - 1);
  // Inner area (black) where progress fills
  const pad = 2;
  const innerW = w - pad * 2;
  const innerH = h - pad * 2;
  ctx.fillStyle = '#000';
  ctx.fillRect(pad, pad, innerW, innerH);
  // Progress
  const needed = xpNeededForNextLevel(uiState.level);
  const pct = Math.max(0, Math.min(1, uiState.xp / needed));
  ctx.fillStyle = '#172fe1';
  ctx.fillRect(pad, pad, Math.floor(innerW * pct), innerH);
  // Ticks at each 1/8
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 1; i < 8; i++) {
    const x = Math.floor(innerW * i / 8) + pad;
    ctx.moveTo(x + 0.5, pad);
    ctx.lineTo(x + 0.5, pad + innerH);
  }
  ctx.stroke();
}, [uiState.level, uiState.xp, xpNeededForNextLevel]);

const render = useCallback(() => {
  const canvas = canvasRef.current;
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return; // jsdom/test environment safeguard
  const canvasWidth = canvasWidthRef.current || CANVAS_WIDTH;
  const canvasHeight = canvasHeightRef.current || CANVAS_HEIGHT;
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  const camera = cameraRef.current;

  // Draw parallax stars (background) - with hyperspace effect support
  if (hyperSpaceJumpEffectRef.current.active && 
      (hyperSpaceJumpEffectRef.current.phase === 'brighten' || 
       hyperSpaceJumpEffectRef.current.phase === 'streaking')) {
    hyperSpaceJumpEffectRef.current.drawStars(ctx, starsRef.current, camera, canvasWidth, canvasHeight);
  } else {
    starsRef.current.forEach((star) => {
      // Calculate parallax position
      const parallaxX = star.x - camera.x * star.parallax;
      const parallaxY = star.y - camera.y * star.parallax;
      
      const screenPos = camera.worldToScreen(parallaxX, parallaxY, canvasWidth, canvasHeight);
      
      // Only draw if visible (with margin for star wrapping)
      if (screenPos.x >= -50 && screenPos.x <= canvasWidth + 50 && 
          screenPos.y >= -50 && screenPos.y <= canvasHeight + 50) {
        ctx.save();
        // Boost perceived brightness ~20% while clamping to 1.0
        ctx.globalAlpha = Math.min(1, star.brightness * 1.2);
        ctx.fillStyle = 'white';
        ctx.fillRect(screenPos.x, screenPos.y, star.size / camera.zoom, star.size / camera.zoom);
        ctx.restore();
      }
    });
  }

  // Draw ship (with hyperspace fade support) - hide during death effect
  if (!deathEffectRef.current.active && shipRef.current && camera.isVisible(shipRef.current.x, shipRef.current.y, 50, canvasWidth, canvasHeight)) {
    const screenPos = camera.worldToScreen(shipRef.current.x, shipRef.current.y, canvasWidth, canvasHeight);
    ctx.save();
    
    // Apply hyperspace opacity if active
    if (hyperSpaceJumpEffectRef.current.active) {
      ctx.globalAlpha = hyperSpaceJumpEffectRef.current.getShipOpacity();
    }
    
    ctx.translate(screenPos.x, screenPos.y);
    ctx.scale(1/camera.zoom, 1/camera.zoom);
    ctx.translate(-shipRef.current.x, -shipRef.current.y);
    shipRef.current.draw(ctx);
    ctx.restore();
  }
  
  // Draw asteroids (with culling and hyperspace fade)
  asteroidsRef.current.forEach((asteroid) => {
    if (asteroid && camera.isVisible(asteroid.x, asteroid.y, asteroid.size, canvasWidth, canvasHeight)) {
      const screenPos = camera.worldToScreen(asteroid.x, asteroid.y, canvasWidth, canvasHeight);
      ctx.save();
      
      // Apply hyperspace opacity if active
      if (hyperSpaceJumpEffectRef.current.active) {
        ctx.globalAlpha = hyperSpaceJumpEffectRef.current.getAsteroidsOpacity();
      }
      ctx.translate(screenPos.x, screenPos.y);
      ctx.scale(1/camera.zoom, 1/camera.zoom);
      // Draw asteroid using its draw method
      ctx.translate(-asteroid.x, -asteroid.y);
      asteroid.draw(ctx);
      ctx.restore();
    }
  });
  
  // Draw bullets (with culling)
  bulletsRef.current.forEach((bullet) => {
    if (bullet && camera.isVisible(bullet.x, bullet.y, bullet.size, canvasWidth, canvasHeight)) {
      const screenPos = camera.worldToScreen(bullet.x, bullet.y, canvasWidth, canvasHeight);
      ctx.save();
      ctx.translate(screenPos.x, screenPos.y);
      ctx.scale(1/camera.zoom, 1/camera.zoom);
      ctx.translate(-bullet.x, -bullet.y);
      bullet.draw(ctx);
      ctx.restore();
    }
  });

  // Draw crosshair at mouse position
  if (gameStartedRef.current) {
    const mousePos = mousePositionRef.current;
    const screenPos = camera.worldToScreen(mousePos.x, mousePos.y, canvasWidth, canvasHeight);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Horizontal line
    ctx.moveTo(screenPos.x - CROSSHAIR_SIZE, screenPos.y);
    ctx.lineTo(screenPos.x + CROSSHAIR_SIZE, screenPos.y);
    // Vertical line
    ctx.moveTo(screenPos.x, screenPos.y - CROSSHAIR_SIZE);
    ctx.lineTo(screenPos.x, screenPos.y + CROSSHAIR_SIZE);
    ctx.stroke();
  }

  // Render minimap separately
  renderMinimap();
  // Render XP bar
  renderXpBar();

  // Draw level-up effects (overlay)
  levelUpEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
  stageClearEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
  hyperSpaceJumpEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
  
  // Draw death effect (after all game objects)
  deathEffectRef.current.draw(ctx, camera, canvasWidth, canvasHeight);
}, [renderMinimap, renderXpBar]);


useEffect(() => {
  const loop = () => {
    update();
    render();
    
    // Throttle UI updates - only update when values actually change
    setUiState((prev) => ({
      ...prev,
      score: scoreRef.current,
      lives: livesRef.current,
      gameOver: gameOverRef.current,
      xp: xpRef.current,
      level: levelRef.current,
    }));
    
    requestRef.current = requestAnimationFrame(loop);
  };
  
  requestRef.current = requestAnimationFrame(loop);
  return () => {
    if (requestRef.current) {
      cancelAnimationFrame(requestRef.current);
    }
  };
}, [update, render]);———3. Starfield generation and drawing mixed with main component
Starfield creation and updates are handled in App.jsx, intertwining background effects with game state logic

Suggested task
Isolate starfield logic in `useStarfield`


const generateStarfield = useCallback(() => {
  const stars = [];
  for (let i = 0; i < STAR_COUNT * STAR_FIELD_MULTIPLIER; i++) { // More stars for bigger world
    // Box-Muller transform for normal distribution
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    
    // Convert to bell curve centered at 0.5 with std dev of 0.15
    let brightness = 0.5 + z0 * 0.15;
    // Clamp to valid range
    brightness = Math.max(STAR_MIN_BRIGHTNESS, Math.min(STAR_MAX_BRIGHTNESS, brightness));
    
    stars.push({
      x: Math.random() * WORLD_WIDTH * STAR_FIELD_SPREAD, // Spread beyond world boundaries
      y: Math.random() * WORLD_HEIGHT * STAR_FIELD_SPREAD,
      brightness: brightness,
      size: brightness > STAR_LARGE_THRESHOLD ? 2 : brightness > STAR_MEDIUM_THRESHOLD ? 1.5 : 1,
      parallax: MIN_PARALLAX + Math.random() * (MAX_PARALLAX - MIN_PARALLAX) // Random parallax speed
    });
  }
  starsRef.current = stars;
}, []);

—————

4. Timer and overlay state clutter App.jsx
Timer utilities (formatTime, startTimer, stopTimer) and overlay rendering (Start, Pause, Death, Game Over) are maintained directly in the main component, further inflating its size


Suggested task
Factor out timer and overlay management


const formatTime = (seconds) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

const startTimer = () => {
  gameStartTimeRef.current = Date.now();
  elapsedTimeRef.current = 0;
  
  if (timerIntervalRef.current) {
    clearInterval(timerIntervalRef.current);
  }
  
  timerIntervalRef.current = setInterval(() => {
    if (!isPausedRef.current && !deathSequenceActiveRef.current && gameStartedRef.current && !gameOverRef.current) {
      const elapsed = Math.floor((Date.now() - gameStartTimeRef.current - pausedTimeRef.current) / 1000);
      elapsedTimeRef.current = elapsed;
      setUiState(prev => ({ ...prev, timeString: formatTime(elapsed) }));
    }
  }, 1000);
};

———

  <StartOverlay onSelect={handleSelectMode} />
)}
{uiState.gameStarted && !uiState.gameOver && uiState.isPaused && (
  <PauseOverlay 
    xp={uiState.xp}
    lives={uiState.lives}
    largeCount={asteroidCountsRef.current.large}
    mediumCount={asteroidCountsRef.current.medium}
    smallCount={asteroidCountsRef.current.small}
    onResume={handleResume}
    onExit={handleExitToMenu}
  />
)}
{uiState.showDeathOverlay && (
  <DeathOverlay 
    mode={uiState.mode}
    wave={stageRef.current}
    level={uiState.level}
    timeString={uiState.timeString}
    livesRemaining={uiState.lives}
    onContinue={handleContinueDeath}
  />
)}
{uiState.gameOver && uiState.finalStats && (
  <GameOverOverlay 
    mode={uiState.mode}
    stats={uiState.finalStats}
    onPlayAgain={handlePlayAgain}
    onMainMenu={handleMainMenu}
  />
)}

—————

5. Excessive constants import in App.jsx
A single 200‑character import brings dozens of constants, hurting readability and obscuring logical groupings

Suggested task
Reorganize constants imports


import { useRef, useEffect, useState, useCallback } from 'react';
import { Ship } from './components/Ship.js';
import { Asteroid } from './components/Asteroid.js';
import { Bullet } from './components/Bullet.js';
import { checkCollision, wrapPosition } from './utils/collision.js';
import { CANVAS_WIDTH, CANVAS_HEIGHT, BULLET_FIRE_RATE, STAR_COUNT, STAR_MIN_BRIGHTNESS, STAR_MAX_BRIGHTNESS, INITIAL_ASTEROID_COUNT, MAX_BULLETS, CROSSHAIR_SIZE, SCORE_PER_ASTEROID, INITIAL_LIVES, STAR_LARGE_THRESHOLD, STAR_MEDIUM_THRESHOLD, WORLD_WIDTH, WORLD_HEIGHT, ZOOM_SPEED, SHIP_FRICTION, SHIP_DECELERATION, STAR_FIELD_MULTIPLIER, STAR_FIELD_SPREAD, MIN_PARALLAX, MAX_PARALLAX, XP_PER_ASTEROID, XP_LEVEL_BASE, XP_LEVEL_GROWTH, ASTEROID_SIZE_LARGE, ASTEROID_SIZE_MEDIUM, ASTEROID_SIZE_SMALL } from './utils/constants.js';

——————

