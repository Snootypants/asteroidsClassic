Starfield logic is tightly coupled to App.jsx
The starfield generation and storage live directly inside App.jsx, mixing rendering concerns with state setup

Suggested task
Extract starfield management into a custom hook

// Generate stars with bell curve distribution
const generateStarfield = useCallback(() => {
  const stars = [];
  for (let i = 0; i < STAR_COUNT * STAR_FIELD_MULTIPLIER; i++) { // More stars for bigger world
    // Box-Muller transform for normal distribution
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    
    // Convert to bell curve centered at 0.5 with std dev of 0.15
    let brightness = 0.5 + z0 * 0.15;
    // Clamp to valid range
    brightness = Math.max(STAR_MIN_BRIGHTNESS, Math.min(STAR_MAX_BRIGHTNESS, brightness));
    
    stars.push({
      x: Math.random() * WORLD_WIDTH * STAR_FIELD_SPREAD, // Spread beyond world boundaries
      y: Math.random() * WORLD_HEIGHT * STAR_FIELD_SPREAD,
      brightness: brightness,
      size: brightness > STAR_LARGE_THRESHOLD ? 2 : brightness > STAR_MEDIUM_THRESHOLD ? 1.5 : 1,
      parallax: MIN_PARALLAX + Math.random() * (MAX_PARALLAX - MIN_PARALLAX) // Random parallax speed
    });
  }
  starsRef.current = stars;
}, []);

————

Asteroid lifecycle, counts, and stage transitions reside in App.jsx
Asteroid setup, counting, and stage advancement are all embedded in the main component

Suggested task
Modularize asteroid management with useAsteroids


const updateAsteroidCounts = useCallback(() => {
  const counts = { large: 0, medium: 0, small: 0 };
  asteroidsRef.current.forEach(asteroid => {
    if (asteroid.size === ASTEROID_SIZE_LARGE) counts.large++;
    else if (asteroid.size === ASTEROID_SIZE_MEDIUM) counts.medium++;
    else if (asteroid.size === ASTEROID_SIZE_SMALL) counts.small++;
  });
  asteroidCountsRef.current = counts;
  
  // Check for stage clear condition
  const totalAsteroids = counts.large + counts.medium + counts.small;
  if (
    totalAsteroids === 0 &&
    gameStartedRef.current &&
    !gameOverRef.current &&
    !stageClearedRef.current &&
    !hyperSpaceJumpEffectRef.current.active
  ) {
    stageClearedRef.current = true;
    stageClearEffectRef.current.trigger();
    // After ~1s, trigger hyperspace jump transition to the next stage
    setTimeout(() => {
      const ship = shipRef.current;
      if (ship) {
        hyperSpaceJumpEffectRef.current.trigger(
          ship.angle,
          stageRef.current,
          baseAsteroidCountRef.current,
          startNewStage
        );
        hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
      }
    }, 1000);
  }
}, []);

const startNewStage = useCallback((stageNumber, asteroidCount) => {
  // Reset game state for new stage
  stageRef.current = stageNumber;
  baseAsteroidCountRef.current = asteroidCount;
  
  // Clear any remaining bullets
  bulletsRef.current = [];
  setBulletCount(0);
  
  // Reset ship position to center
  if (shipRef.current) {
    shipRef.current.x = WORLD_WIDTH / 2;
    shipRef.current.y = WORLD_HEIGHT / 2;
    shipRef.current.vx = 0;
    shipRef.current.vy = 0;
  }
  
  // Spawn new asteroids
  initializeAsteroids(asteroidCount);
  
  // Reset stage cleared flag
  stageClearedRef.current = false;
  
  // Regenerate starfield
  generateStarfield();
}, [initializeAsteroids, generateStarfield]);

// Initialize asteroids and stars
useEffect(() => {
  initializeAsteroids();

————

Input event wiring dominates the main component
Keyboard/mouse listeners and related handlers span a large effect, complicating readability

Suggested task
Isolate input handling via useInputControls

// Handle pointer lock and mouse/keyboard input
useEffect(() => {
  const handleKeyDown = (e) => {
    if (['KeyW', 'KeyS', 'Space', 'Escape', 'Tab', 'Digit1', 'Digit2', 'Digit3'].includes(e.code)) {
      e.preventDefault();
    }

    keysRef.current[e.code] = true;
    
    // Handle pause toggle with ESC
    if (e.code === 'Escape' && gameStartedRef.current && !gameOverRef.current) {
      isPausedRef.current = !isPausedRef.current;
      setUiState(prev => ({ ...prev, isPaused: isPausedRef.current }));
    }
    
    // Toggle testing mode with Tab
    if (e.code === 'Tab') {
      testingModeRef.current = !testingModeRef.current;
      setUiState(prev => ({ ...prev, testingMode: testingModeRef.current }));
    }
    
    // Testing mode effect triggers
    if (testingModeRef.current && gameStartedRef.current) {
      if (e.code === 'Digit1') {
        triggerLevelUp(levelRef.current);
      }
      if (e.code === 'Digit2') {
        stageClearEffectRef.current.trigger();
      }
      if (e.code === 'Digit3') {
        const ship = shipRef.current;
        if (ship) {
          hyperSpaceJumpEffectRef.current.trigger(
            ship.angle,
            stageRef.current,
            baseAsteroidCountRef.current,
            startNewStage
          );
          hyperSpaceJumpEffectRef.current.initStarVelocities(starsRef.current);
        }
      }
      if (e.code === 'Digit4') {
        // Trigger game over for testing
        gameOverRef.current = true;
        stopTimer();
        setUiState(prev => ({ 
          ...prev, 
          gameOver: true,
          finalStats: {
            wave: stageRef.current,
            level: levelRef.current,
            score: scoreRef.current,
            timeString: formatTime(elapsedTimeRef.current)
          }
        }));
      }
      if (e.code === 'Digit5') {
        // Trigger death effect for testing
        const ship = shipRef.current;
        if (ship) {
          console.log('Test trigger: Death effect at ship position', ship.x, ship.y);
          deathEffectRef.current.trigger(ship.x, ship.y);
          livesRef.current = 0; // Set lives to 0 to trigger game over sequence
          console.log('Death effect active:', deathEffectRef.current.active);
        }
      }
    }
  };
  
  const handleKeyUp = (e) => {
    keysRef.current[e.code] = false;
  };


  const handleMouseMove = (e) => {
    if (canvasRef.current && gameStartedRef.current) {
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      const camera = cameraRef.current;
      
      // Get mouse position relative to canvas
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;
      // Persist screen-space position for idle reprojection
      mouseScreenRef.current.x = canvasX;
      mouseScreenRef.current.y = canvasY;
      
      // Convert canvas coordinates to world coordinates
      const worldPos = camera.screenToWorld(canvasX, canvasY, canvas.width, canvas.height);
      
      mousePositionRef.current.x = worldPos.x;
      mousePositionRef.current.y = worldPos.y;
    }
  };

  const handleMouseDown = (e) => {
    if (e.button === 0 && gameStartedRef.current && !gameOverRef.current) {
      isMouseDownRef.current = true;
      // fire immediately; update loop will handle steady cadence
      shootBullet(true);
    }
  };

  const handleMouseUp = (e) => {
    if (e.button === 0) {
      isMouseDownRef.current = false;
    }
  };

  const handleWheel = (e) => {
    e.preventDefault();
    const camera = cameraRef.current;
    const zoomDelta = e.deltaY > 0 ? ZOOM_SPEED : -ZOOM_SPEED;
    camera.setZoom(camera.targetZoom + zoomDelta);
  };

  const handleCanvasClick = (e) => {
    if (hyperSpaceJumpEffectRef.current.phase === 'waiting') {
      hyperSpaceJumpEffectRef.current.startNewStage();
    }
  };
  
  if (canvasRef.current) {
    canvasRef.current.addEventListener('click', handleCanvasClick);
  }

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mousedown', handleMouseDown);
  document.addEventListener('mouseup', handleMouseUp);
  document.addEventListener('wheel', handleWheel);
  
  return () => {
    window.removeEventListener('keydown', handleKeyDown);
    window.removeEventListener('keyup', handleKeyUp);
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mousedown', handleMouseDown);
    document.removeEventListener('mouseup', handleMouseUp);
    document.removeEventListener('wheel', handleWheel);
    if (canvasRef.current) {
      canvasRef.current.removeEventListener('click', handleCanvasClick);
    }
  };
}, [triggerLevelUp, startNewStage]);

——————

Timer utilities clutter App.jsx
Time formatting, start/stop logic, and interval tracking sit inline with gameplay code

Suggested task
Create a reusable useGameTimer hook

const formatTime = (seconds) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

const startTimer = () => {
  gameStartTimeRef.current = Date.now();
  elapsedTimeRef.current = 0;
  
  if (timerIntervalRef.current) {
    clearInterval(timerIntervalRef.current);
  }
  
  timerIntervalRef.current = setInterval(() => {
    if (!isPausedRef.current && !deathSequenceActiveRef.current && gameStartedRef.current && !gameOverRef.current) {
      const elapsed = Math.floor((Date.now() - gameStartTimeRef.current - pausedTimeRef.current) / 1000);
      elapsedTimeRef.current = elapsed;
      setUiState(prev => ({ ...prev, timeString: formatTime(elapsed) }));
    }
  }, 1000);
};

const stopTimer = () => {
  if (timerIntervalRef.current) {
    clearInterval(timerIntervalRef.current);
    timerIntervalRef.current = null;
  }
};

———

The update function covers multiple responsibilities
update handles ship physics, bullets, collisions, effects, and score, making it hard to reason about

Suggested task
Split game-state updates into focused modules

const update = useCallback(() => {
  // ALWAYS update death effect, even during pause
  if (deathEffectRef.current.active) {
    deathEffectRef.current.update();
  }
  
  // Check for game over after death effect completes
  if (deathEffectRef.current.isDone() && livesRef.current <= 0 && !gameOverRef.current) {
    deathSequenceActiveRef.current = false; // Unpause for game over screen
    gameOverRef.current = true;
    stopTimer();
    setUiState(prev => ({ 
      ...prev, 
      gameOver: true,
      finalStats: {
        wave: stageRef.current,
        level: levelRef.current,
        score: scoreRef.current,
        timeString: formatTime(elapsedTimeRef.current)
      }
    }));
    deathEffectRef.current.reset();
  }
  
  // Now check pause conditions (but exclude death effect from the check)
  if (gameOverRef.current || !gameStartedRef.current || isPausedRef.current || deathSequenceActiveRef.current) return;

  // Update camera zoom
  const camera = cameraRef.current;
  camera.updateZoom();

  // Update ship - aims at crosshair, moves with W/S
  const keys = keysRef.current;
  const ship = shipRef.current;
  
  if (deathEffectRef.current.active) {
    // Skip ship update during death effect
  } else {
    // Reproject last known screen mouse into world space even if mouse is idle.
    // This prevents the crosshair from becoming stale when the camera moves.
    const canvasWidth = canvasWidthRef.current || CANVAS_WIDTH;
    const canvasHeight = canvasHeightRef.current || CANVAS_HEIGHT;
    const reproj = camera.screenToWorld(
      mouseScreenRef.current.x,
      mouseScreenRef.current.y,
      canvasWidth,
      canvasHeight
    );
    mousePositionRef.current.x = reproj.x;
    mousePositionRef.current.y = reproj.y;
    const mousePos = mousePositionRef.current;
    
    // Calculate angle to mouse crosshair
    const dx = mousePos.x - ship.x;
    const dy = mousePos.y - ship.y;
    ship.angle = Math.atan2(dy, dx);
    
    // W/S movement controls
    if (keys.KeyW) {
      ship.vx += Math.cos(ship.angle) * ship.speed;
      ship.vy += Math.sin(ship.angle) * ship.speed;
    }
    
    // Apply velocity and friction
    ship.x += ship.vx;
    ship.y += ship.vy;
    
    // S key brakes (slows down to zero, no reverse)
    if (keys.KeyS) {
      ship.vx *= SHIP_DECELERATION;
      ship.vy *= SHIP_DECELERATION;
    } else {
      ship.vx *= SHIP_FRICTION;
      ship.vy *= SHIP_FRICTION;
    }
    wrapPosition(ship); // World wrapping

    // Update camera to follow ship
    camera.followShip(ship.x, ship.y, canvasWidth, canvasHeight);
  }

  // Update asteroids
  asteroidsRef.current.forEach((asteroid) => {
    asteroid.update();
    wrapPosition(asteroid); // World wrapping
  });

  // Update bullets
  bulletsRef.current.forEach((bullet) => {
    bullet.update();
    wrapPosition(bullet); // World wrapping
  });
  bulletsRef.current = bulletsRef.current.filter((bullet) => !bullet.isExpired());
  setBulletCount(bulletsRef.current.length);

  // Unified, smooth firing cadence for Space or LMB hold
  const currentTime = Date.now();
  const isFiring = keys.Space || isMouseDownRef.current;
  if (
    isFiring &&
    currentTime - lastShotTimeRef.current >= BULLET_FIRE_RATE &&
    bulletsRef.current.length < MAX_BULLETS
  ) {
    bulletsRef.current.push(new Bullet(ship.x, ship.y, ship.angle));
    lastShotTimeRef.current = currentTime;
    setBulletCount(bulletsRef.current.length);
  }

  // Collisions
  let asteroidsToRemove = [];
  let bulletsToRemove = [];
  let newAsteroids = [];

  bulletsRef.current.forEach((bullet, bi) => {
    asteroidsRef.current.forEach((asteroid, ai) => {
      if (checkCollision(bullet, asteroid)) {
        if (!bulletsToRemove.includes(bi)) bulletsToRemove.push(bi);
        if (!asteroidsToRemove.includes(ai)) asteroidsToRemove.push(ai);
        newAsteroids.push(...asteroid.split());
        scoreRef.current += SCORE_PER_ASTEROID;
        addXp(XP_PER_ASTEROID);
      }
    });
  });

  // Remove collided items (iterate backwards to avoid index issues)
  bulletsToRemove.sort((a, b) => b - a).forEach(index => {
    bulletsRef.current.splice(index, 1);
  });
  asteroidsToRemove.sort((a, b) => b - a).forEach(index => {
    asteroidsRef.current.splice(index, 1);
  });
  
  // Add new asteroids from splits
  asteroidsRef.current.push(...newAsteroids);

  // Ship collision - only check if not invulnerable and not in death sequence
  if (!deathSequenceActiveRef.current && shipRef.current && !shipRef.current.invulnerable) {
    let shipCollisionIndex = -1;
    let shipCollisionSplits = [];
    
    asteroidsRef.current.forEach((asteroid, ai) => {
      if (checkCollision(shipRef.current, asteroid)) {
        livesRef.current -= 1;
        shipCollisionSplits = asteroid.split();
        shipCollisionIndex = ai;
        
        // Pause game immediately
        deathSequenceActiveRef.current = true;
        pauseStartRef.current = Date.now(); // Track when pause started
        
        // Trigger death effect
        deathEffectRef.current.trigger(shipRef.current.x, shipRef.current.y);
        
        if (livesRef.current > 0) {
          // Show death overlay after explosion
          setTimeout(() => {
            setUiState(prev => ({ 
              ...prev, 
              showDeathOverlay: true,
              lives: livesRef.current
            }));
          }, 1500);
        }
      }
    });
    
    // Remove asteroid and add splits
    if (shipCollisionIndex >= 0) {
      asteroidsRef.current.splice(shipCollisionIndex, 1);
      asteroidsRef.current.push(...shipCollisionSplits);
    }
  }

  // Update invulnerability
  if (shipRef.current && shipRef.current.invulnerable) {
    if (Date.now() > shipRef.current.invulnerableUntil) {
      shipRef.current.invulnerable = false;
    }
  }

  // Level-up effect update
  levelUpEffectRef.current.update();
  stageClearEffectRef.current.update();
  hyperSpaceJumpEffectRef.current.update();
  hyperSpaceJumpEffectRef.current.updateStars(starsRef.current);
  
  // Update asteroid counts for active tracking
  updateAsteroidCounts();

———

Game loop useEffect is embedded in the component
The requestAnimationFrame loop lives directly in App.jsx alongside other concerns

Suggested task
Encapsulate the render loop with useGameLoop

useEffect(() => {
  const loop = () => {
    update();
    render();
    
    // Throttle UI updates - only update when values actually change
    setUiState((prev) => ({
      ...prev,
      score: scoreRef.current,
      lives: livesRef.current,
      gameOver: gameOverRef.current,
      xp: xpRef.current,
      level: levelRef.current,
    }));
    
    requestRef.current = requestAnimationFrame(loop);
  };
  
  requestRef.current = requestAnimationFrame(loop);
  return () => {
    if (requestRef.current) {
      cancelAnimationFrame(requestRef.current);
    }
  };
}, [update, render]);

————

Layout calculations are interwoven with gameplay logic
Responsive layout computations and DOM measurements occupy a lengthy effect in App.jsx

Suggested task
Extract responsive layout logic to useGameLayout

// Dynamic layout system with fixed margins and locked aspect ratio
useEffect(() => {
  const updateGameLayout = () => {
    // Fixed margins
    const MARGIN_LEFT = 100;
    const MARGIN_RIGHT = 100;
    const MARGIN_TOP = 100;
    const MARGIN_BOTTOM = 200;
    
    // Target aspect ratio 1349:817
    const ASPECT_RATIO = 1349 / 817; // ≈1.6514041591
    
    // Minimap sizing: width is a proportion of the play area,
    // height derived from the WORLD aspect ratio so the shape matches the world.
    const MINIMAP_WIDTH_RATIO = 0.3276501112; // keep visual width similar to before
    
    // Calculate available box
    const availableWidth = window.innerWidth - MARGIN_LEFT - MARGIN_RIGHT;
    const availableHeight = window.innerHeight - MARGIN_TOP - MARGIN_BOTTOM;
    
    // Calculate play area size maintaining aspect ratio
    let playWidth, playHeight;
    if (availableWidth / availableHeight > ASPECT_RATIO) {
      // Height-constrained
      playHeight = availableHeight;
      playWidth = Math.round(playHeight * ASPECT_RATIO);
    } else {
      // Width-constrained
      playWidth = availableWidth;
      playHeight = Math.round(playWidth / ASPECT_RATIO);
    }
    
    // Center play area within available box
    const playX = MARGIN_LEFT + Math.round((availableWidth - playWidth) / 2);
    const playY = MARGIN_TOP + Math.round((availableHeight - playHeight) / 2);
    
    // Calculate minimap dimensions using world aspect ratio
    const worldAspect = WORLD_HEIGHT / WORLD_WIDTH; // H/W
    let minimapWidth = Math.round(playWidth * MINIMAP_WIDTH_RATIO);
    let minimapHeight = Math.round(minimapWidth * worldAspect);
    // Guard: if height would exceed a reasonable portion of play area, cap by height and recompute width
    const MAX_MINIMAP_HEIGHT_RATIO = 0.2; // at most 20% of play height
    const maxMinimapHeight = Math.round(playHeight * MAX_MINIMAP_HEIGHT_RATIO);
    if (minimapHeight > maxMinimapHeight) {
      minimapHeight = maxMinimapHeight;
      minimapWidth = Math.round(minimapHeight / worldAspect);
    }
    
    // Apply styles to play area via ref
    const playArea = playAreaRef.current;
    if (playArea) {
      playArea.style.left = `${playX}px`;
      playArea.style.top = `${playY}px`;
      playArea.style.width = `${playWidth}px`;
      playArea.style.height = `${playHeight}px`;
    }
    
    // Update canvas dimensions
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = playWidth - 4; // Account for 2px border on each side
      canvas.height = playHeight - 4;
    }
    
    // Update minimap dimensions and ensure it's positioned within play area
    const minimapCanvas = minimapCanvasRef.current;
    if (minimapCanvas) {
      minimapCanvas.width = minimapWidth;
      minimapCanvas.height = minimapHeight;
      minimapCanvas.style.width = `${minimapWidth}px`;
      minimapCanvas.style.height = `${minimapHeight}px`;
      if (import.meta.env.DEV) {
        console.log('Minimap dimensions set:', minimapWidth, minimapHeight);
      }
    }

    // Keep minimap and stats vertically aligned regardless of window size
    const minimapBottom = -Math.round(minimapHeight * 0.75); // show top 1/4 overlapping play area

——————

Rendering helpers mix UI and game concerns
Functions like renderMinimap and renderXpBar remain embedded, rather than reusable components or hooks

Suggested task
Move rendering helpers into dedicated modules

const renderMinimap = useCallback(() => {
  const minimapCanvas = minimapCanvasRef.current;
  if (!minimapCanvas) return;
  const ctx = minimapCanvas.getContext('2d');
  if (!ctx) return; // jsdom/test environment safeguard
  Minimap.draw(ctx, shipRef.current, asteroidsRef.current, cameraRef.current);
}, []);

const renderXpBar = useCallback(() => {
  const canvas = xpBarCanvasRef.current;
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);
  // Solid black box with golden border
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);
  ctx.strokeStyle = '#d4af37';
  ctx.lineWidth = 2;
  ctx.strokeRect(0.5, 0.5, w - 1, h - 1);
  // Inner area (black) where progress fills
  const pad = 2;
  const innerW = w - pad * 2;
  const innerH = h - pad * 2;
  ctx.fillStyle = '#000';
  ctx.fillRect(pad, pad, innerW, innerH);
  // Progress
  const needed = xpNeededForNextLevel(uiState.level);
  const pct = Math.max(0, Math.min(1, uiState.xp / needed));
  ctx.fillStyle = '#172fe1';
  ctx.fillRect(pad, pad, Math.floor(innerW * pct), innerH);
  // Ticks at each 1/8
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 1; i < 8; i++) {
    const x = Math.floor(innerW * i / 8) + pad;
    ctx.moveTo(x + 0.5, pad);
    ctx.lineTo(x + 0.5, pad + innerH);
  }
  ctx.stroke();
}, [uiState.level, uiState.xp, xpNeededForNextLevel]);